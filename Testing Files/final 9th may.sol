// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract Bank {
    using SafeMath for uint256;

    // Variables for dynamic interest rate calculation
    uint256 public BASE_INTEREST_RATE = 1000;
    uint256 public MAX_INTEREST_RATE = 1800;
    uint256 public TOTAL_DEPOSITED = 10000000000000000000;
    uint256 public TOTAL_BORROWED = 7000000000000000000;
    uint256 public TIME_CONVERSION = 60; // Used to convert seconds to weeks

    address public collateralTokenAddress = 0x01db35078E09d2C4751c1E04b168965FdB66f58A; // Collateral token address
    address public lendingTokenAddress = 0x86ef4Ad0E7cdaDfF58FAB38291e3e226Ab0e7223; // Lending token address
    uint256 public profit = 0; // Profits generated by the contract
    uint256 public ex_rate = 100; //1 LT = 1 CT (ex_rate =200, 1LT = 2 CT)
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    // User reputation mapping
    mapping(address => uint256) public reputation;

    // Borrower mapping
    mapping(address => uint256[3]) private borrowerData;
    mapping(address => bool) private borrowerInitialized;

    // Lender mapping
    mapping(address => uint256[3]) private lenderData;
    mapping(address => bool) private lenderInitialized;

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function.");
        _;
    }

    function withdrawProfits(address payable recipient, uint256 amount) public onlyOwner {
        require(profit > amount, "Insufficient profit to withdraw.");
        profit -= amount;
        IERC20(lendingTokenAddress).transfer(recipient, amount);
    }

    function calculateInterestRate() public view returns (uint256) {
        uint256 difference = MAX_INTEREST_RATE.sub(BASE_INTEREST_RATE);
        uint256 ratio = TOTAL_BORROWED.mul(1e18).div(TOTAL_DEPOSITED);
        uint256 product = difference.mul(ratio).div(1e18);
        uint256 interestRate = BASE_INTEREST_RATE.add(product);

        return interestRate;
    }

    function calculateMinimumDeposit() public view returns (uint256, uint256) {
        uint256 interestRate = calculateInterestRate() + (100 - borrowerData[msg.sender][2]).mul(10) + 200;
        uint256 minDeposit = borrowerData[msg.sender][0]
            .mul(interestRate)
            .div(10000);

        return (minDeposit, borrowerData[msg.sender][1] - block.timestamp); // minimum deposit and time till next payment
    }

    // Borrower Functions
    function borrowerDepositCollateral(uint256 amount, uint256 collateralPercentage) public {
        if (!borrowerInitialized[msg.sender]) {
            borrowerInitialized[msg.sender] = true;
        }

        require(borrowerData[msg.sender][0] == 0, "Loan already taken.");
        require(reputation[msg.sender] >= amount.mul(100 - collateralPercentage).div(100), "Insufficient reputation.");
        borrowerData[msg.sender] = [amount, block.timestamp + TIME_CONVERSION, collateralPercentage];

        IERC20(collateralTokenAddress).transferFrom(msg.sender, address(this), amount.mul(collateralPercentage).mul(ex_rate).div(10000));
        IERC20(lendingTokenAddress).transferFrom( address(this),msg.sender, amount);

        reputation[msg.sender] -= amount.mul(100 - collateralPercentage).div(100);
        TOTAL_BORROWED += amount;
}

function borrowerPayInterest() public {
    uint256 interestRate = calculateInterestRate() + (100 - borrowerData[msg.sender][2]).mul(10) + 200;
    uint256 minDeposit = borrowerData[msg.sender][0]
        .mul(interestRate)
        .div(10000);
    
    require(borrowerData[msg.sender][1] - block.timestamp > 1, "Failed to pay on time.");

    IERC20(lendingTokenAddress).transferFrom(msg.sender, address(this), minDeposit);

    borrowerData[msg.sender][1] += TIME_CONVERSION;
    profit += minDeposit.mul(2).div(100);
    reputation[msg.sender] += minDeposit.div(10);
}

function borrowerRepayLoan() public {
    uint256 loanAmount = borrowerData[msg.sender][0];
    
    require(borrowerData[msg.sender][1] - block.timestamp > 0, "Failed to pay interest in time");

    IERC20(lendingTokenAddress).transferFrom(msg.sender, address(this), loanAmount);
    IERC20(collateralTokenAddress).transferFrom(address(this),msg.sender, loanAmount.mul(borrowerData[msg.sender][2]).mul(ex_rate).div(10000));

    borrowerData[msg.sender] = [0, 0, 0];
    TOTAL_BORROWED -= loanAmount;
    reputation[msg.sender] += loanAmount.mul(110).div(100);
}

// Lender Functions
function lenderDeposit(uint256 amount) public {
    require(amount > 0, "Deposit amount must be greater than 0.");
    uint256 interestRate = calculateInterestRate();

    IERC20(lendingTokenAddress).transferFrom(msg.sender, address(this), amount);

    if (!lenderInitialized[msg.sender]) {
        lenderInitialized[msg.sender] = true;
        lenderData[msg.sender] = [amount, block.timestamp, 0];
        TOTAL_DEPOSITED += amount;
    } else {
        lenderData[msg.sender][2] += (block.timestamp - lenderData[msg.sender][1])
                                        .mul(lenderData[msg.sender][0])
                                        .div(TIME_CONVERSION)
                                        .mul(interestRate)
                                        .div(10000);
        lenderData[msg.sender][0] += amount;
        lenderData[msg.sender][1] = block.timestamp;
        TOTAL_DEPOSITED += amount;
    }
}

function lenderWithdrawPrincipal(uint256 amount) public {
    require(lenderInitialized[msg.sender], "User does not have an initialized array.");
    require(lenderData[msg.sender][0] >= amount, "Insufficient balance for withdrawal.");

    uint256 interestRate = calculateInterestRate();

    lenderData[msg.sender][2] += (block.timestamp - lenderData[msg.sender][1])
                                    .mul(lenderData[msg.sender][0])
                                    .div(TIME_CONVERSION)
                                    .mul(interestRate)
                                    .div(10000);
    lenderData[msg.sender][0] -= amount;
    lenderData[msg.sender][1] = block.timestamp;

    IERC20(lendingTokenAddress).transfer(msg.sender, amount);
    TOTAL_DEPOSITED -= amount;
}

function lenderWithdrawInterest() public {
    require(lenderInitialized[msg.sender], "User does not have an initialized array.");

    uint256 interestRate = calculateInterestRate();

    uint256 interestEarned = (block.timestamp - lenderData[msg.sender][1])
                                .mul(lenderData[msg.sender][0])
                                .div(TIME_CONVERSION)
                                .mul(interestRate)
                                .div(10000);

    uint256 totalInterest = lenderData[msg.sender][2] + interestEarned;
    require(totalInterest > 0, "No interest to withdraw.");

    lenderData[msg.sender][2] = 0;
    lenderData[msg.sender][1] = block.timestamp;

    IERC20(lendingTokenAddress).transfer(msg.sender, totalInterest);
}

function lenderViewInterest() public view returns (uint256) {
    require(lenderInitialized[msg.sender], "User does not have an initialized array.");

    uint256 interestRate = calculateInterestRate();

    uint256 interestEarned = (block.timestamp - lenderData[msg.sender][1])
                                .mul(lenderData[msg.sender][0])
                                .div(TIME_CONVERSION)
                                .mul(interestRate)
                                .div(10000);

    uint256 totalInterest = lenderData[msg.sender][2] + interestEarned;
    return totalInterest;
}

// Utility Functions
function resetReputation(uint256 reputationAmount) public {
    reputation[msg.sender] = reputationAmount;
}
function exrate(uint256 rate) public {
    ex_rate = rate;
}

function resetLenderData() public {
    lenderData[msg.sender] = [0, 0, 0];
}

function resetBorrowerData() public {
    borrowerData[msg.sender] = [0, 0, 0];
}

function getUserData() public view returns (uint256[3] memory, uint256[3] memory, uint256) {
    return (borrowerData[msg.sender], lenderData[msg.sender], reputation[msg.sender]);
}

function getContractBalance() public view returns (uint256) {
    return address(this).balance;
}


}